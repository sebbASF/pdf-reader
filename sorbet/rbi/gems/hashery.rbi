# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/hashery/all/hashery.rbi
#
# hashery-2.1.2

class Hash
  def rekey!(key_map = nil, &block); end
  def rekey(key_map = nil, &block); end
  def retrieve(key); end
  def self.[](*arg0); end
end
module Hashery
end
class Hashery::CRUDHash < Hash
  def <<(assoc); end
  def [](key); end
  def []=(key, value); end
  def cast(hash); end
  def cast_key(key); end
  def default_proc(&block); end
  def delete(key); end
  def each; end
  def each_pair; end
  def fetch(key, *default); end
  def has_key?(key); end
  def include?(key); end
  def key?(key); end
  def key_proc(&block); end
  def key_proc=(proc); end
  def member?(key); end
  def merge!(other); end
  def merge(other); end
  def read(key); end
  def replace(other); end
  def retrieve(key); end
  def self.[](*hash); end
  def self.auto(*args, &block); end
  def store(key, value); end
  def to_h; end
  def to_hash; end
  def update(other); end
  def values_at(*keys); end
end
class Hashery::CastingHash < Hashery::CRUDHash
  def cast(hash); end
  def cast_pair(key, value); end
  def cast_proc(&proc); end
  def cast_proc=(proc); end
  def initialize(default = nil, &cast_proc); end
  def recast!; end
  def replace(other); end
  def self.[](hash); end
  def store(key, value); end
  def to_h; end
  def to_hash; end
end
class Hashery::Dictionary
  def <<(kv); end
  def ==(hsh2); end
  def [](key); end
  def []=(k, i = nil, v = nil); end
  def clear; end
  def delete(key); end
  def delete_if; end
  def dup; end
  def each; end
  def each_key; end
  def each_pair; end
  def each_value; end
  def empty?; end
  def fetch(key, *a, &b); end
  def first(x = nil); end
  def has_key?(key); end
  def hash_table; end
  def initialize(*args, &blk); end
  def insert(index, key, value); end
  def inspect; end
  def invert; end
  def key?(key); end
  def keys; end
  def last(x = nil); end
  def length; end
  def merge!(hsh2); end
  def merge(hsh2); end
  def order; end
  def order_by(&block); end
  def order_by_key; end
  def order_by_value; end
  def pop; end
  def push(k, v); end
  def reject!(&block); end
  def reject(&block); end
  def reorder; end
  def replace(hsh2); end
  def reverse!; end
  def reverse; end
  def select; end
  def self.[](*args); end
  def self.alpha(*args, &block); end
  def self.alphabetic(*args, &block); end
  def self.auto(*args); end
  def self.new_by(*args, &blk); end
  def shift; end
  def size; end
  def store(key, value); end
  def to_a; end
  def to_h; end
  def to_hash; end
  def to_s; end
  def unshift(k, v); end
  def update(hsh2); end
  def values; end
  include Enumerable
end
class Hashery::FuzzyHash
  def ==(o); end
  def [](key); end
  def []=(key, value); end
  def clear; end
  def count; end
  def delete_value(value); end
  def each; end
  def empty?; end
  def fuzz_test; end
  def fuzz_test=(arg0); end
  def fuzzies; end
  def fuzzies_reverse; end
  def fuzzy_hash; end
  def fuzzy_lookup(key); end
  def hash; end
  def hash_reverse; end
  def initialize(init_hash = nil); end
  def keys; end
  def match_with_result(key); end
  def replace(src, dest); end
  def reset_fuzz_test!; end
  def size; end
  def values; end
end
class Hashery::IniHash
  def [](key); end
  def []=(key, value); end
  def comment; end
  def comment=(arg0); end
  def inihash; end
  def inihash=(arg0); end
  def initialize(path, load = nil); end
  def inspect; end
  def method_missing(s, *a, &b); end
  def restore; end
  def save; end
  def self.load(path, load = nil); end
  def self.read_comment_from_file(path); end
  def self.read_from_file(path); end
  def self.text(inihash = nil); end
  def self.to_s(inihash = nil); end
  def self.write_to_file(path, inihash = nil, comment = nil); end
  def to_h; end
  def to_s; end
  def update; end
end
class Hashery::LinkedList
  def <<(v); end
  def [](key); end
  def []=(k, v); end
  def delete(key); end
  def each; end
  def empty?; end
  def first; end
  def initialize; end
  def last; end
  def length; end
  def node_delete(n); end
  def node_join(a, b); end
  def node_purge(n); end
  def pop; end
  def push(v); end
  def queue; end
  def shift; end
  def size; end
  def to_a; end
  def unshift(v); end
  include Enumerable
end
class Hashery::LinkedList::Node
  def initialize(key = nil, value = nil, prev_node = nil, next_node = nil); end
  def key; end
  def key=(arg0); end
  def next_node; end
  def next_node=(arg0); end
  def prev_node; end
  def prev_node=(arg0); end
  def value; end
  def value=(arg0); end
end
class Hashery::LRUHash
  def [](key); end
  def []=(key, value); end
  def assoc(key); end
  def clear; end
  def default; end
  def default=(arg0); end
  def default_proc; end
  def default_proc=(arg0); end
  def delete(key); end
  def delete_if; end
  def delete_oldest; end
  def each; end
  def each_key; end
  def each_node; end
  def each_pair; end
  def each_value; end
  def empty?; end
  def fetch(key, &b); end
  def front(node); end
  def has_key?(key); end
  def has_value?(value); end
  def include?(key); end
  def initialize(max_size, default_value = nil, &block); end
  def inspect; end
  def key(value); end
  def key?(key); end
  def keys; end
  def max_size; end
  def max_size=(limit); end
  def member?(key); end
  def normalize_max(n); end
  def rassoc(value); end
  def release_proc; end
  def release_proc=(arg0); end
  def remove_node(node); end
  def size; end
  def store(key, value); end
  def to_s; end
  def value?(value); end
  def values; end
  def values_at(*key_list); end
  include Enumerable
end
class Hashery::LRUHash::Node < Struct
  def insert_after(node); end
  def key; end
  def key=(_); end
  def pred; end
  def pred=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def succ; end
  def succ=(_); end
  def unlink; end
  def value; end
  def value=(_); end
end
class Hashery::KeyHash < Hashery::CRUDHash
  def initialize(*default, &block); end
end
class Hashery::OpenHash < Hashery::CRUDHash
  def close!(*methods); end
  def initialize(default = nil, safe = nil, &block); end
  def method_missing(s, *a, &b); end
  def object_class; end
  def omit!(*methods); end
  def open!(*methods); end
  def open?(method); end
  def safe; end
  def safe=(arg0); end
  def store(key, value); end
end
class Hashery::OpenCascade < Hashery::OpenHash
  def cast_value(entry); end
  def initialize(*default); end
  def method_missing(sym, *args, &blk); end
  def respond_to?(sym, include_private = nil); end
  def retrieve!(key); end
  def retrieve(key); end
end
class Hashery::PropertyHash < Hashery::CRUDHash
  def assert_key!(key); end
  def initialize(properties = nil, &default_proc); end
  def property(key, opts = nil); end
  def self.properties; end
  def self.property(key, opts = nil); end
  def store!(key, value); end
  def store(key, value); end
end
class Hashery::QueryHash < Hashery::CRUDHash
  def initialize(*default, &default_proc); end
  def method_missing(s, *a, &b); end
  def respond_to?(name); end
end
class Hashery::StaticHash < Hashery::CRUDHash
  def store(key, value); end
end
