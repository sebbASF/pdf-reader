# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/cane/all/cane.rbi
#
# cane-3.0.0

module Cane
  def default_checks; end
  def run(*args); end
  def self.default_checks; end
  def self.run(*args); end
  def self.task_runner(opts); end
  def task_runner(opts); end
end
class Cane::ViolationFormatter
  def colorize(string); end
  def column_widths(violations, columns); end
  def format_group_header(description, violations); end
  def format_violation(v, column_widths); end
  def format_violations(violations); end
  def initialize(violations, options = nil); end
  def options; end
  def to_s; end
  def totals; end
  def violations; end
end
class Cane::JsonFormatter
  def initialize(violations, options = nil); end
  def to_s; end
end
class Cane::Runner
  def checks; end
  def formatter; end
  def initialize(spec); end
  def opts; end
  def outputter; end
  def run; end
  def violations; end
end
class Cane::EncodingAwareIterator
  def each(&block); end
  def initialize(lines); end
  def lines; end
  include Enumerable
end
class Cane::File
  def self.case_insensitive_glob(glob); end
  def self.contents(path); end
  def self.exists?(path); end
  def self.iterator(path); end
  def self.open(path); end
end
class Cane::SimpleTaskRunner
  def self.map(enumerable, &block); end
end
class Anonymous_Struct_1 < Struct
  def opts; end
  def opts=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class Cane::AbcCheck < Anonymous_Struct_1
  def exclusions; end
  def file_names; end
  def find_violations(file_name); end
  def max_allowed_complexity; end
  def order(result); end
  def self.key; end
  def self.name; end
  def self.options; end
  def violations; end
  def worker; end
end
class Anonymous_Struct_2 < Struct
  def file_name; end
  def file_name=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class Cane::AbcCheck::InvalidAst < Anonymous_Struct_2
  def violations; end
end
class Anonymous_Struct_3 < Struct
  def exclusions; end
  def exclusions=(_); end
  def file_name; end
  def file_name=(_); end
  def max_allowed_complexity; end
  def max_allowed_complexity=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def sexps; end
  def sexps=(_); end
end
class Cane::AbcCheck::RubyAst < Anonymous_Struct_3
  def anon_method_add; end
  def anon_method_add=(arg0); end
  def assignment_nodes; end
  def branch_nodes; end
  def calculate_abc(method_node); end
  def condition_nodes; end
  def container_label(node); end
  def container_nodes; end
  def count_nodes(node, types); end
  def excluded?(method_description); end
  def initialize(*args); end
  def label_for(node); end
  def method_description(node, *modules, meth_name); end
  def method_nodes; end
  def process_ast(node, complexity = nil, nesting = nil); end
  def violations; end
end
class Anonymous_Struct_4 < Struct
  def opts; end
  def opts=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class Cane::StyleCheck < Anonymous_Struct_4
  def excluded?(file); end
  def exclusions; end
  def file_list; end
  def map_lines(file_path, &block); end
  def measure; end
  def self.key; end
  def self.name; end
  def self.options; end
  def violations; end
  def violations_for_line(line); end
  def worker; end
end
class Anonymous_Struct_5 < Struct
  def opts; end
  def opts=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class Cane::DocCheck < Anonymous_Struct_5
  def class_definition(number, line, last_line); end
  def class_definition?(line); end
  def class_definitions_in(file_name); end
  def comment?(line); end
  def excluded?(file); end
  def exclusions; end
  def extract_class_name(line); end
  def file_names; end
  def find_violations(file_name); end
  def method_definition?(line); end
  def missing_file_violations; end
  def self.key; end
  def self.name; end
  def self.options; end
  def single_line_class_definition?(line); end
  def violations; end
  def worker; end
end
class Cane::DocCheck::ClassDefinition < Struct
  def label; end
  def line; end
  def missing_doc?; end
  def requires_doc=(value); end
  def requires_doc?; end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def values; end
  def values=(_); end
end
class Anonymous_Struct_6 < Struct
  def opts; end
  def opts=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class Cane::ThresholdCheck < Anonymous_Struct_6
  def normalized_limit(limit); end
  def self.key; end
  def self.options; end
  def thresholds; end
  def value_from_file(file); end
  def violations; end
end
class Cane::ThresholdCheck::UnavailableValue
  def >=(_); end
  def real?; end
  def to_s; end
end
module Cane::CLI
  def default_options; end
  def defaults(check); end
  def run(args); end
  def self.default_options; end
  def self.defaults(check); end
  def self.run(args); end
end
class Cane::CLI::Parser
  def add_banner; end
  def add_cane_options; end
  def add_check_options(check); end
  def add_checks_shortcut; end
  def add_help; end
  def add_option(option, description, opts = nil); end
  def add_user_defined_checks; end
  def add_version; end
  def get_default_options; end
  def initialize(stdout = nil); end
  def options; end
  def parse(args, ret = nil); end
  def parser; end
  def read_options_from_file(file); end
  def self.parse(*args); end
  def stdout; end
end
class Cane::CLI::Parser::OptionsHandled < RuntimeError
end
